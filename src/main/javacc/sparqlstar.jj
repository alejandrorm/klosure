options
{
  // Use \ u escapes in streams AND use a reader for the query
  // => get both raw and escaped unicode

  JAVA_UNICODE_ESCAPE   = true;
  UNICODE_INPUT         = true;
  IGNORE_CASE           = true;
  STATIC                = false;
  DEBUG_PARSER          = false;
  DEBUG_TOKEN_MANAGER   = false;
  FORCE_LA_CHECK        = true;
  LOOKAHEAD             = 2;
}

PARSER_BEGIN(SparqlStarParser)

package me.alejandrorm.klosure.parser.sparql;

import org.semanticweb.owlapi.model.IRI;

import java.util.*;

import me.alejandrorm.klosure.model.*;
import me.alejandrorm.klosure.model.literals.*;
import me.alejandrorm.klosure.sparql.*;
//import me.alejandrorm.klosure.sparql.algebra.*;
import me.alejandrorm.klosure.sparql.algebra.operators.*;
import me.alejandrorm.klosure.sparql.algebra.path.*;
import me.alejandrorm.klosure.sparql.algebra.filters.*;
import me.alejandrorm.klosure.sparql.algebra.filters.builtins.*;
import me.alejandrorm.klosure.sparql.algebra.filters.operators.*;
import me.alejandrorm.klosure.sparql.algebra.filters.operators.arithmetic.*;

public class SparqlStarParser {

    private static final String NAMESPACE_PREFIX = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";

    private final Map<String, String> prefixes = new HashMap<>();

    private String base = "";

    private class TermAndTriples {
        public TermOrVariable term;
        public List<TriplePattern> patterns;

        public TermAndTriples(TermOrVariable term, List<TriplePattern> patterns) {
            this.term = term;
            this.patterns = patterns;
        }
    }

    private class VerbAndObjects {
        public TermOrVariable verb;
        public Path path;
        public List<TermAndTriples> objectsAndTriples;

        public VerbAndObjects(TermOrVariable verb, Path path, List<TermAndTriples> objectsAndTriples) {
            this.verb = verb;
            this.path = path;
            this.objectsAndTriples = objectsAndTriples;
        }

        public VerbAndObjects(Path path, List<TermAndTriples> objectsAndTriples) {
            this.path = path;
            this.objectsAndTriples = objectsAndTriples;
        }
    }

    private class VerbObjectAnnotation {
        public IRI verb;
        public Node object;
        public List<VerbObjectAnnotation> annotations = new ArrayList<>();

        public void addAll(Node subject, Graph graph) {
            PredicateNode triple = graph.getOrCreatePredicate(subject, verb, object, true);
            for (VerbObjectAnnotation voa : annotations) {
                voa.addAll(triple, graph);
            }
        }
     }

     private class ObjectAnnotation {
        public Node object;
        public List<VerbObjectAnnotation> annotations = new ArrayList<>();
     }

     private List<TriplePattern> getTriples(TermOrVariable subject, List<VerbAndObjects> vos) {
        List<TriplePattern> triples = new ArrayList<>();
        for (VerbAndObjects vo : vos) {
            if (vo.path != null){
                for (TermAndTriples tat : vo.objectsAndTriples) {
                    triples.add(vo.path.compile(subject, tat.term));
                    triples.addAll(tat.patterns);
                }
            }else {
                for (TermAndTriples tat : vo.objectsAndTriples) {
                    triples.add(new BasicTriplePattern(subject, vo.verb, tat.term));
                    triples.addAll(tat.patterns);
                }
            }
        }
        return triples;
     }

     private List<TriplePattern> getTriples(TermAndTriples tat,
                                            List<VerbAndObjects> maybeVos) {
         List<TriplePattern> triples = new ArrayList<>(tat.patterns);
         if(maybeVos != null) {
             for (VerbAndObjects vo : maybeVos) {
                 if (vo.path != null){
                     for (TermAndTriples tat2 : vo.objectsAndTriples) {
                         triples.add(vo.path.compile(tat.term, tat2.term));
                         triples.addAll(tat2.patterns);
                     }
                 } else {
                     for (TermAndTriples tat2 : vo.objectsAndTriples) {
                         triples.add(new BasicTriplePattern(tat.term, vo.verb, tat2.term));
                         triples.addAll(tat.patterns);
                     }
                 }
             }
         }
         return triples;
     }
}


PARSER_END(SparqlStarParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

<DEFAULT> SKIP : { <COMMENT : "#" (~["\n"])* ("\n") > : DEFAULT }

Query QueryUnit():
{
  Query q;
}
{
  q = Query() { return q;}
}

// TODO
Query Query():
{
  Query q = null;
}
{
  Prologue() ( q = SelectQuery() | ConstructQuery() | DescribeQuery() | q = AskQuery()) ValuesClause() { return q;}
}

void UpdateUnit():
{}
{
  Update()
}

void Prologue():
{}
{
  (BaseDecl() | PrefixDecl()) *
}

void BaseDecl():
{
 Token t;
}
{
  "BASE" t = <IRIREF> { base = t.image.substring(1, t.image.length()-1); }
}

void PrefixDecl():
{
 Token t1, t2;
}
{
  "PREFIX" t1 = <PNAME_NS> t2 = <IRIREF> { prefixes.put(t1.image, base + t2.image.substring(1, t2.image.length()-1)); }
}

Query SelectQuery():
{
  AlgebraOperator a;
  ProjectArguments s;
  SolutionModifier sm;
}
{
  s = SelectClause() (DatasetClause()) * a = WhereClause() sm = SolutionModifier() {
 return new SelectQuery(new Project(s, a), sm);
 }
}

// TODO
AlgebraOperator SubSelect():
{
  AlgebraOperator a;
  ProjectArguments s;
}
{
  s = SelectClause() a = WhereClause() SolutionModifier() ValuesClause() {
 return new Project(s, a); }
}

ProjectArguments SelectClause():
{
  Variable v;
  Expression e;
  List<ExpressionVariableBinding> variables = new ArrayList<>();
  boolean distinct = false;
}
{
  "SELECT" ( "DISTINCT" { distinct = true; } | "REDUCED") ? ( ( v = Var() {
      variables.add(new ExpressionVariableBinding(new VariableExpression(v), v)); } |
       "(" e = Expression() "AS" v = Var() ")" {
       variables.add(new ExpressionVariableBinding(e, v));
       }) + | "*") {
    return new ProjectArguments(distinct, variables);
  }
}

void ConstructQuery():
{}
{
  "CONSTRUCT"
   ConstructTemplate() (DatasetClause())* WhereClause() SolutionModifier() (DatasetClause())* "WHERE" "{" (TriplesTemplate())? "}" SolutionModifier()
}

void DescribeQuery():
{}
{
  "DESCRIBE" ( (VarOrIri())+ | "*") (DatasetClause())* (WhereClause())? SolutionModifier()
}

Query AskQuery():
{
  AlgebraOperator a;
}
{
  "ASK" (DatasetClause())* a = WhereClause() ValuesClause() { return new AskQuery(a); }
}

// TODO
void DatasetClause():
{}
{
  "FROM" ( DefaultGraphClause() | NamedGraphClause())
}

// TODO
void DefaultGraphClause():
{}
{
  SourceSelector()
}

// TODO
void NamedGraphClause():
{}
{
  "NAMED" SourceSelector()
}

// TODO
void SourceSelector():
{}
{
  iri()
}

AlgebraOperator WhereClause():
{
  AlgebraOperator a;
}
{
  ("WHERE")? a = GroupGraphPattern() { return a; }
}

// TODO
SolutionModifier SolutionModifier():
{
  Limit l = null;
}
{
  (GroupClause())? (HavingClause())? (OrderClause())? (l = LimitOffsetClauses())? { return new SolutionModifier(l); }
}


// TODO
void GroupClause():
{}
{
  "GROUP" "BY" (GroupCondition())+
}

// TODO
void GroupCondition():
{}
{
  BuiltInCall() |
  FunctionCall() |
  ( "(" Expression() ( "AS" Var()) ? ")") |
  Var()
}

// TODO
void HavingClause():
{}
{
  "HAVING" (HavingCondition())+
}

// TODO
void HavingCondition():
{}
{
  Constraint()
}

// TODO
void OrderClause():
{}
{
  "ORDER" "BY" (OrderCondition())+
}

// TODO
void OrderCondition():
{}
{
  ( ( "ASC" | "DESC") BrackettedExpression()) |
  Constraint() |
  Var()
}

Limit LimitOffsetClauses():
{
  int limit = 0;
  int offset = 0;
}
{
  limit = LimitClause() (offset = OffsetClause())? {
    return new Limit(limit, offset);
  } |
  offset = OffsetClause() (limit = LimitClause())? {
    return new Limit(limit, offset);
  }
}

int LimitClause():
{
 long limit = 0;
}
{
"LIMIT" limit = Integer() { return (int)limit; }
}

int OffsetClause():
{
 long offset = 0;
 }
{
  "OFFSET" offset = Integer() { return (int)offset; }
}

// TODO
void ValuesClause():
{}
{
  ("VALUES" DataBlock()) ?
}

void Update():
{}
{
  Prologue() ( Update1() ( ";" Update()) ? ) ?
}

void Update1():
{}
{
  Load() | Clear() | Drop() | Add() | Move() | Copy() | Create() | InsertData() | DeleteData() | DeleteWhere() | Modify()
}

void Load():
{}
{
  "LOAD" ("SILENT")? iri() ( "INTO" GraphRef()) ?
}

void Clear():
{}
{
  "CLEAR" ("SILENT")? GraphRefAll()
}

void Drop():
{}
{
  "DROP" ("SILENT")? GraphRefAll()
}

void Create():
{}
{
  "CREATE" ("SILENT")? GraphRef()
}

void Add():
{}
{
  "ADD" ("SILENT")? GraphOrDefault() "TO" GraphOrDefault()
}

void Move():
{}
{
  "MOVE" ("SILENT")? GraphOrDefault() "TO" GraphOrDefault()
}

void Copy():
{}
{
  "COPY" ("SILENT")? GraphOrDefault() "TO" GraphOrDefault()
}

void InsertData():
{}
{
  "INSERT DATA" QuadData()
}

void DeleteData():
{}
{
  "DELETE DATA" QuadData()
}

void DeleteWhere():
{}
{
  "DELETE WHERE" QuadPattern()
}

void Modify():
{}
{
  ( "WITH" iri()) ? ( ( DeleteClause() (InsertClause())? ) | InsertClause()) (UsingClause())* "WHERE" GroupGraphPattern()
}

void DeleteClause():
{}
{
  "DELETE" QuadPattern()
}

void InsertClause():
{}
{
  "INSERT" QuadPattern()
}

void UsingClause():
{}
{
  "USING" ( iri() | ( "NAMED" iri()) )
}

void GraphOrDefault():
{}
{
  "DEFAULT" | ( ("GRAPH")? iri())
}

void GraphRef():
{}
{
  "GRAPH" iri()
}

void GraphRefAll():
{}
{
  GraphRef() | "DEFAULT" | "NAMED" | "ALL"
}

void QuadPattern():
{}
{
  "{" Quads() "}"
}

void QuadData():
{}
{
  "{" Quads() "}"
}

void Quads():
{}
{
  (TriplesTemplate())? ( QuadsNotTriples() (".")? (TriplesTemplate())? ) *
}

void QuadsNotTriples():
{}
{
  "GRAPH" VarOrIri() "{" (TriplesTemplate())? "}"
}

void TriplesTemplate():
{}
{
  TriplesSameSubject() ( "." (TriplesTemplate())? ) ?
}

AlgebraOperator GroupGraphPattern():
{
  AlgebraOperator algebraOperator;
}
{
  "{" ( algebraOperator = SubSelect() | algebraOperator = GroupGraphPatternSub()) "}" { return algebraOperator; }
}

AlgebraOperator GroupGraphPatternSub():
{
  List<AlgebraOperator> gps = new ArrayList<AlgebraOperator>();
  AlgebraOperator gp = null;
  List<TriplePattern> triples;
}
{
  (triples = TriplesBlock() { gps.add(new BasicGraphPattern(triples)); })?
   ( gp = GraphPatternNotTriples() {
     if (gp instanceof FakeLeftJoin) {
       AlgebraOperator left = gps.remove(gps.size() - 1);
       AlgebraOperator right = ((FakeLeftJoin)gp).getOperator();
       gps.add(new LeftJoin(left, right));
     } else {
       gps.add(gp);
     }
   }(".")? (triples = TriplesBlock() { gps.add(new BasicGraphPattern(triples)); })? ) * {
     if (gps.size() == 1) {
       return gps.get(0);
     } else {
       return new Join(gps);
     }
   }
}

//TODO: separate groups of triples with the same subject
List<TriplePattern> TriplesBlock():
{
  List<TriplePattern> triples = new ArrayList<>();
  List<TriplePattern> t;
}
{
  t = TriplesSameSubjectPath() { triples.addAll(t); }
  ( "." (t = TriplesBlock() { triples.addAll(t); })? ) ? { return triples; }
}

//TODO: implement this
AlgebraOperator GraphPatternNotTriples():
{
  AlgebraOperator a;
}
{
  a = GroupOrUnionGraphPattern() { return a; } |
  a = OptionalGraphPattern() { return a; }|
  a = MinusGraphPattern() { return a; }|
  GraphGraphPattern() { return new Identity(); }|
  ServiceGraphPattern() { return new Identity(); }|
  a = Filter() { return a; }|
  a = Bind() { return a; }|
  InlineData() { return new Identity(); }
}

AlgebraOperator OptionalGraphPattern():
{
  AlgebraOperator a;
}
{
  "OPTIONAL" a = GroupGraphPattern() { return new FakeLeftJoin(a); }
}

// TODO: implement this
void GraphGraphPattern():
{}
{
  "GRAPH" VarOrIri() GroupGraphPattern()
}

void ServiceGraphPattern():
{}
{
  "SERVICE" ("SILENT")? VarOrIri() GroupGraphPattern()
}

AlgebraOperator Bind():
{
  Expression e;
  Variable v;
}
{
  "BIND" "(" e = Expression() "AS" v = Var() ")" { return new Bind(e, v); }
}

void InlineData():
{}
{
  "VALUES" DataBlock()
}

void DataBlock():
{}
{
  InlineDataOneVar() |
  InlineDataFull()
}

void InlineDataOneVar():
{}
{
  Var() "{" (DataBlockValue())* "}"
}

void InlineDataFull():
{}
{
  ( <NIL> | ( "(" (Var())* ")") ) "{" ( ( "(" (DataBlockValue())* ")") | <NIL>) * "}"
}

void DataBlockValue():
{}
{
  QuotedTriple() |
  iri() |
  RDFLiteral() |
  NumericLiteral() |
  BooleanLiteral() |
  "UNDEF"
}

AlgebraOperator MinusGraphPattern():
{
  AlgebraOperator a;
}
{
  "MINUS" a = GroupGraphPattern() { return new Minus(a); }
}

AlgebraOperator GroupOrUnionGraphPattern():
{
  AlgebraOperator a;
  List<AlgebraOperator> ops = new ArrayList<AlgebraOperator>();
}
{
  a = GroupGraphPattern() { ops.add(a); }( "UNION" a = GroupGraphPattern() { ops.add(a); }) * { return new Union(ops); }
}

AlgebraOperator Filter():
{
 Expression e;
}
{
  "FILTER" e = Constraint() { return new Filter(e); }
}

// TODO expression or aggregate expression
Expression Constraint():
{
   Expression e;
}
{
  e = BrackettedExpression() { return e; }|
  e = BuiltInCall() { return e; }|
  e = FunctionCall() { return e; }
}

// TODO
Expression FunctionCall():
{}
{
  iri() ArgList() { return new UnsupportedBuiltinExpression("casting"); }
}

void ArgList():
{}
{
  <NIL> | ( "(" ("DISTINCT")? Expression() ( "," Expression()) * ")")
}

List<Expression> ExpressionList():
{
  Expression e;
  List<Expression> list = new ArrayList<>();
}
{
  <NIL> { return list;} |
   "(" e = Expression() { list.add(e); }( "," e = Expression() { list.add(e); }) * ")" { return list;}
}

void ConstructTemplate():
{}
{
  "{" (ConstructTriples())? "}"
}

void ConstructTriples():
{}
{
  TriplesSameSubject() ( "." (ConstructTriples())? ) ?
}

void TriplesSameSubject():
{}
{
  ( VarOrTermOrQuotedTP() PropertyListNotEmpty()) | ( TriplesNode() PropertyList())
}

List<VerbAndObjects>  PropertyList():
{
 List<VerbAndObjects> vos = null;
}
{
  (vos = PropertyListNotEmpty())? { return vos; }
}

List<VerbAndObjects> PropertyListNotEmpty():
{
  List<VerbAndObjects> vos = new ArrayList<>();
  List<TermAndTriples> tts = null;
  TermOrVariable t = null;
}
{
  t = Verb() tts = ObjectList() {
    vos.add(new VerbAndObjects(t, null, tts)); t = null; tts = null;
  }
  ( ";" ( t = Verb() tts = ObjectList() {
    vos.add(new VerbAndObjects(t, null, tts)); t = null; tts = null;
  }) ? ) * { return vos; }
}

TermOrVariable Verb():
{
  TermOrVariable v;
}
{
  v = VarOrIri() { return v;}|
  "A" { return new TermOrVariable.NodeOrIriTerm(new IriId(IRI.create(NAMESPACE_PREFIX + "type"))); }
}

List<TermAndTriples> ObjectList():
{
  List<TermAndTriples>  tts = new ArrayList<>();
  TermAndTriples tt;
}
{
  tt = Object() { tts.add(tt); } ( "," tt = Object() { tts.add(tt); }) * { return tts; }
}

TermAndTriples Object():
{
  TermAndTriples t;
}
{
  t = GraphNode() (AnnotationPattern() { /* TODO */})? { return t;}
}

List<TriplePattern> TriplesSameSubjectPath():
{
  TermOrVariable subject;
  List<VerbAndObjects> vos;
  TermAndTriples tat;
  List<VerbAndObjects> maybeVos;
}
{
  ( subject = VarOrTermOrQuotedTP() vos = PropertyListPathNotEmpty() {
    return getTriples(subject, vos);
  }) | ( tat = TriplesNodePath() vos = PropertyListPath() {
    return getTriples(tat, vos);
  })
}

List<VerbAndObjects> PropertyListPath():
{
 List<VerbAndObjects> vos = null;
}
{
  (vos = PropertyListPathNotEmpty())? { return vos; }
}

List<VerbAndObjects> PropertyListPathNotEmpty():
{
  List<VerbAndObjects> vos = new ArrayList<>();
  List<TermAndTriples> tts = null;
  Path p = null;
  TermOrVariable t = null;
}
{
  ( p = Path() | t = VerbSimple()) tts = ObjectListPath() {
    vos.add(new VerbAndObjects(t, p, tts)); p = null; t = null; tts = null;
  } ( ";" ( ( p = Path() | t = VerbSimple()) tts = ObjectList() {
    vos.add(new VerbAndObjects(t, p, tts)); p = null; t = null; tts = null;
  }) ? ) * { return vos; }
}

TermOrVariable VerbSimple():
{
    Variable v;
}
{
  v = Var() { return new  TermOrVariable.VariableTerm(v); }
}

List<TermAndTriples> ObjectListPath():
{
  List<TermAndTriples> tts = new ArrayList<>();
  TermAndTriples tt;
}
{
  tt = ObjectPath() { tts.add(tt); } ( "," tt = ObjectPath() { tts.add(tt); }) * { return tts; }
}

TermAndTriples ObjectPath():
{
  TermAndTriples t;
}
{
  t = GraphNodePath() (AnnotationPatternPath() { /* TODO */})? { return t;}
}

Path Path():
{
  Path p;
}
{
  p = PathAlternative() { return p; }
}

Path PathAlternative():
{
  List<Path> paths = new ArrayList<>();
  Path p;
}
{
  p = PathSequence() { paths.add(p); }( "|" p = PathSequence() { paths.add(p); }) * {

    if (paths.size() == 1) {
      return paths.get(0);
    } else {
      return new AlternatePath(paths);
    }
  }
}

Path PathSequence():
{
  Path p;
  List<Path> paths = new ArrayList<>();
}
{
  p = PathEltOrInverse() { paths.add(p); }( "/" p = PathEltOrInverse() { paths.add(p); }) * {
    if (paths.size() == 1) {
      return paths.get(0);
    } else {
      return new SequencePath(paths);
    }
  }
}

Path PathElt():
{
  Path p;
  int mode = -1;
}
{
  p = PathPrimary() ( mode = PathMod())? {
    switch(mode) {
      case -1:
        return p;
      case 0:
        return new ZeroOrMorePath(p);
      case 1:
        return new ZeroOrOnePath(p);
      case 2:
        return new OneOrMorePath(p);
      default:
        throw new RuntimeException("Invalid path mode");
    }
  }
}

Path PathEltOrInverse():
{
  Path p;
}
{
  p = PathElt() { return p; }|
  ( "^" p = PathElt() { return new InversePath(p); })
}

int PathMod():
{}
{
  "*" { return 0; } |
  "?" { return 1; }|
  "+" { return 2; }
}

Path PathPrimary():
{
  Path p;
  IRI i;
}
{
  i = iri() { return new IriPath(i); }|
  "A" { return new IriPath(IRI.create(NAMESPACE_PREFIX + "type")); }|
  ( "!" p = PathNegatedPropertySet() { return new NegatedPath(p); }) |
  p = ParenthesisPath() { return p; } //( "(" p = Path() { return p; }")")
}

Path ParenthesisPath():
{
  Path p;
}
{
  "(" p = Path() ")" { return p; }
}

Path PathNegatedPropertySet():
{
  Path p;
  List<Path> paths = new ArrayList<>();
}
{
  p = PathOneInPropertySet() { return p; }|
  "(" ( p = PathOneInPropertySet() { paths.add(p); }( "|" p = PathOneInPropertySet() { paths.add(p); }) * ) ? ")" {
    return new AlternatePath(paths);
  }
}

Path PathOneInPropertySet():
{
  IRI i;
}
{
  i = iri() { return new IriPath(i); }|
  "A" { return new IriPath(IRI.create(NAMESPACE_PREFIX + "type")); }|
  ( "^" ( i = iri() { return new InversePath(new IriPath(i)); } | "A" { return new InversePath(new IriPath(IRI.create(NAMESPACE_PREFIX + "type")));}) )
}

long Integer():
{
 Token t;
}
{
  t = <INTEGER> { return Long.parseLong(t.image); }
}

TermAndTriples TriplesNode():
{
  TermAndTriples tt;
}
{
  tt = Collection() { return tt;}|
  tt = BlankNodePropertyList() { return tt; }
}

TermAndTriples BlankNodePropertyList():
{
  List<VerbAndObjects> l;
}
{
  "[" l = PropertyListNotEmpty() "]" {
     TermOrVariable t = new TermOrVariable.VariableTerm(new Variable(UUID.randomUUID().toString(), true));
     return new TermAndTriples(t, getTriples(t, l));
   }
}

TermAndTriples TriplesNodePath():
{
  TermAndTriples t;
}
{
  t = CollectionPath() { return t; }|
  t = BlankNodePropertyListPath() { return t; }
}

TermAndTriples BlankNodePropertyListPath():
{
  List<VerbAndObjects> l;
}
{
  "[" l = PropertyListPathNotEmpty() "]" {
    TermOrVariable t = new TermOrVariable.VariableTerm(new Variable(UUID.randomUUID().toString(), true));
    return new TermAndTriples(t, getTriples(t, l));
  }
}

TermAndTriples Collection():
{
  List<TermAndTriples> list = new ArrayList<>();
  TermAndTriples t;
}
{
  "(" (t = GraphNode() { list.add(t); })+ ")"
  {
    List<TriplePattern> patterns = new ArrayList<>();
    List<TermOrVariable> terms = new ArrayList<>();
    for(TermAndTriples tat : list) {
      patterns.addAll(tat.patterns);
      terms.add(tat.term);
    }

    ListTerm lt = ListTerm.create(terms);
    patterns.addAll(lt.getListStructure());
    return new TermAndTriples(lt.getNode(), patterns);
  }
}

TermAndTriples CollectionPath():
{
  List<TermAndTriples> list = new ArrayList<>();
  TermAndTriples t;
}
{
  "(" (t = GraphNodePath() { list.add(t); })+ ")"
  {
    List<TriplePattern> patterns = new ArrayList<>();
    List<TermOrVariable> terms = new ArrayList<>();
    for(TermAndTriples tat : list) {
      patterns.addAll(tat.patterns);
      terms.add(tat.term);
    }

    ListTerm lt = ListTerm.create(terms);
    patterns.addAll(lt.getListStructure());
    return new TermAndTriples(lt.getNode(), patterns);
  }
}

TermAndTriples GraphNode():
{
   TermOrVariable t;
   TermAndTriples tt;
}
{
  t = VarOrTermOrQuotedTP() { return new TermAndTriples(t, Collections.emptyList()); }|
  tt = TriplesNode() { return tt; }
}

TermAndTriples GraphNodePath():
{
  TermOrVariable t;
  TermAndTriples tt;
}
{
  t = VarOrTermOrQuotedTP() { return new TermAndTriples(t, Collections.emptyList()); }|
  tt = TriplesNodePath() { return tt; }
}

//void VarOrTerm():
//{}
//{
//  Var() | GraphTerm()
//}

TermOrVariable VarOrIri():
{
  Variable v;
  IRI i;
}
{
  v = Var() { return new TermOrVariable.VariableTerm(v); }|
  i = iri() { return new TermOrVariable.NodeOrIriTerm(new IriId(i)); }
}

Variable Var():
{
  Token t;
}
{
  t = <VAR1> { return new Variable(t.image.substring(1), false); } |
  t = <VAR2> { return new Variable(t.image.substring(1), false); }
}

TermOrVariable GraphTerm():
{
  LiteralId lid;
  IRI i;
  BlankId b;
}
{
  i = iri() { return new TermOrVariable.NodeOrIriTerm(new IriId(i)); }|
  lid = RDFLiteral() { return new TermOrVariable.NodeOrIriTerm(lid); }|
  lid = NumericLiteral() { return new TermOrVariable.NodeOrIriTerm(lid); }|
  lid = BooleanLiteral() { return new TermOrVariable.NodeOrIriTerm(lid); }|
  b = BlankNode() { return new TermOrVariable.VariableTerm(new Variable(b.getName(), true)); }|
  <NIL> { return ListTerm.getNILL_TERM().getNode(); }
}

Expression Expression():
{
 Expression e;
 }
{
  e = ConditionalOrExpression() { return e; }
}

Expression ConditionalOrExpression():
{
  Expression e;
  List<Expression> expressions = new ArrayList<>();
}
{
  e = ConditionalAndExpression() { expressions.add(e); } ( "||" e = ConditionalAndExpression() { expressions.add(e); }) *
  {
    if (expressions.size() == 1) {
      return expressions.get(0);
    } else {
        OrExpression ae = new OrExpression(expressions.get(0), expressions.get(1));
        for(int i = 2; i < expressions.size(); i++) {
          ae = new OrExpression(ae, expressions.get(i));
        }
        return ae;
    }
  }
}

Expression ConditionalAndExpression():
{
  Expression e;
  List<Expression> expressions = new ArrayList<>();
}
{
  e = ValueLogical() { expressions.add(e); }( "&&" e = ValueLogical() { expressions.add(e); }) *
  {
    if (expressions.size() == 1) {
      return expressions.get(0);
    } else {
        AndExpression ae = new AndExpression(expressions.get(0), expressions.get(1));
        for(int i = 2; i < expressions.size(); i++) {
          ae = new AndExpression(ae, expressions.get(i));
        }
        return ae;
    }
  }
}

Expression ValueLogical():
{
  Expression e;
}
{
  e = RelationalExpression() { return e; }
}

Expression RelationalExpression():
{
  Expression e1;
  Expression e2;
  List<Expression> es;
 }
{
  e1 = NumericExpression()

(  "=" e2 = NumericExpression() { return new EqualExpression(e1, e2); }  |
 "!=" e2 = NumericExpression() { return new DifferentExpression(e1, e2); } |
 "<" e2 = NumericExpression() { return new LessThanExpression(e1, e2); }|
 ">" e2 = NumericExpression() { return new GreaterThanExpression(e1, e2); }|
 "<=" e2 = NumericExpression() { return new LessOrEqualThanExpression(e1, e2);}|
 ">=" e2 = NumericExpression() { return new GreaterOrEqualThanExpression(e1, e2);}|
 "IN" es = ExpressionList() { return new InExpression(e1, es); }|
 "NOT" "IN" es = ExpressionList() { return new NotInExpression(e1, es); }) ? { return  e1;}
}

Expression NumericExpression():
{
 Expression e;
}
{
  e = AdditiveExpression() { return e; }
}

Expression AdditiveExpression():
{
    Expression e;
    List<AdditiveOperatorOperand> expressions = new ArrayList<>();
    LiteralId id;
    Expression u1 = null;
    Expression u2 = null;
 }
{
  e = MultiplicativeExpression() { expressions.add(new AdditiveOperatorOperand(AdditiveOperator.PLUS, e)); }
 (  "+" e = MultiplicativeExpression() { expressions.add(new AdditiveOperatorOperand(AdditiveOperator.PLUS, e)); } |
    "-" e = MultiplicativeExpression() { expressions.add(new AdditiveOperatorOperand(AdditiveOperator.MINUS, e)); } |
  ( ( id = NumericLiteralPositive() | id =  NumericLiteralNegative())
   (  "*" u1 = UnaryExpression() |  "/" u2 = UnaryExpression() ) ? {
   if (u1 != null) {
     expressions.add(new AdditiveOperatorOperand(AdditiveOperator.PLUS,
        new MultiplicativeExpression(new LiteralExpression(id), Arrays.asList(new MultiplicativeOperatorOperand(MultiplicativeOperator.TIMES, u1)))));
   } else if (u2 != null) {
     expressions.add(new AdditiveOperatorOperand(AdditiveOperator.PLUS,
        new MultiplicativeExpression(new LiteralExpression(id), Arrays.asList(new MultiplicativeOperatorOperand(MultiplicativeOperator.BY, u2)))));
   } else {
     expressions.add(new AdditiveOperatorOperand(AdditiveOperator.PLUS, new LiteralExpression(id)));
   }
   u1 = null;
   u2 = null;
  } ) ) * { return new AdditiveExpression(expressions); }
}

Expression MultiplicativeExpression():
{
    Expression e;
    Expression e1;
     List<MultiplicativeOperatorOperand> expressions = new ArrayList<>();
 }
{
  e = UnaryExpression() ( ( "*" e1 = UnaryExpression() { expressions.add(new MultiplicativeOperatorOperand(MultiplicativeOperator.TIMES, e1)); }) |
   ( "/" e1 = UnaryExpression() { expressions.add(new MultiplicativeOperatorOperand(MultiplicativeOperator.BY, e1)); }) ) *
   {
     if (expressions.size() == 1) { return e; }
     else { return new MultiplicativeExpression(e, expressions); }
    }
}

Expression UnaryExpression():
{
  Expression e;
}
{
  "!" e = PrimaryExpression() { return new NotExpression(e); } |
   "+" e = PrimaryExpression() { return e; }|
   "-" e = PrimaryExpression() { return new MinusExpression(e); }|
  e = PrimaryExpression() { return e;}
}

Expression PrimaryExpression():
{
  Expression e;
  LiteralId id;
  Variable v;
}
{
  e = BrackettedExpression() { return e;} |
  e = BuiltInCall() { return e;}|
  e = iriOrFunction() { return e;}|
  id = RDFLiteral() { return new LiteralExpression(id); }|
  id = NumericLiteral() { return new LiteralExpression(id); }|
  id = BooleanLiteral() { return new LiteralExpression(id); }|
  v = Var() { return new VariableExpression(v); }|
  e = ExprQuotedTP() { return e; }
}

Expression BrackettedExpression():
{
  Expression e;
}
{
  "(" e = Expression() ")" { return e; }
}

Expression BuiltInCall():
{
  Expression e1, e2, e3;
  Variable v;
}
{
  Aggregate() { return new UnsupportedBuiltinExpression("aggregate"); }
|	"STR" "(" Expression() ")" { return new UnsupportedBuiltinExpression("str"); }
|	"LANG" "(" Expression() ")" { return new UnsupportedBuiltinExpression("lang"); }
|	"LANGMATCHES" "(" Expression() "," Expression() ")" { return new UnsupportedBuiltinExpression("langmatches"); }
|	"DATATYPE" "(" e1 = Expression() ")" { return new Datatype(e1); }
|	"BOUND" "(" v = Var() ")" { return new Bound(v); }
|   "IRI" "(" Expression() ")" { return new UnsupportedBuiltinExpression("iri"); }
|	"URI" "(" Expression() ")" { return new UnsupportedBuiltinExpression("uri"); }
|	"BNODE" ( ( "(" Expression() ")") | <NIL>)  { return new UnsupportedBuiltinExpression("bnode"); }
|	"RAND" <NIL> { return new UnsupportedBuiltinExpression("rand"); }
|	"ABS" "(" e1 = Expression() ")" { return new Abs(e1); }
|	"CEIL" "(" Expression() ")" { return new UnsupportedBuiltinExpression("ceil"); }
|	"FLOOR" "(" Expression() ")" { return new UnsupportedBuiltinExpression("floor"); }
|	"ROUND" "(" Expression() ")" { return new UnsupportedBuiltinExpression("round"); }
|	"CONCAT" ExpressionList() { return new UnsupportedBuiltinExpression("concat"); }
|	SubstringExpression() { return new UnsupportedBuiltinExpression("substring"); }
|	"STRLEN" "(" Expression() ")" { return new UnsupportedBuiltinExpression("strlen"); }
|	StrReplaceExpression() { return new UnsupportedBuiltinExpression("strreplace"); }
|	"UCASE" "(" Expression() ")" { return new UnsupportedBuiltinExpression("ucase"); }
|	"LCASE" "(" Expression() ")" { return new UnsupportedBuiltinExpression("lcase"); }
|	"ENCODE_FOR_URI" "(" Expression() ")" { return new UnsupportedBuiltinExpression("encode_for_uri"); }
|	"CONTAINS" "(" Expression() "," Expression() ")" { return new UnsupportedBuiltinExpression("contains"); }
|	"STRSTARTS" "(" Expression() "," Expression() ")" { return new UnsupportedBuiltinExpression("strstarts"); }
|	"STRENDS" "(" Expression() "," Expression() ")" { return new UnsupportedBuiltinExpression("strends"); }
|	"STRBEFORE" "(" Expression() "," Expression() ")" { return new UnsupportedBuiltinExpression("strbefore"); }
|	"STRAFTER" "(" Expression() "," Expression() ")"  { return new UnsupportedBuiltinExpression("strafter"); }
|	"YEAR" "(" Expression() ")" { return new UnsupportedBuiltinExpression("year"); }
|	"MONTH" "(" Expression() ")" { return new UnsupportedBuiltinExpression("month"); }
|	"DAY" "(" Expression() ")" { return new UnsupportedBuiltinExpression("day"); }
|	"HOURS" "(" Expression() ")" { return new UnsupportedBuiltinExpression("hours"); }
|	"MINUTES" "(" Expression() ")" { return new UnsupportedBuiltinExpression("minutes"); }
|	"SECONDS" "(" Expression() ")" { return new UnsupportedBuiltinExpression("seconds"); }
|	"TIMEZONE" "(" Expression() ")" { return new UnsupportedBuiltinExpression("timezone"); }
|	"TZ" "(" Expression() ")" { return new UnsupportedBuiltinExpression("tz"); }
|	"NOW" <NIL> { return new UnsupportedBuiltinExpression("now"); }
|	"UUID" <NIL> { return new UnsupportedBuiltinExpression("uuid"); }
|	"STRUUID" <NIL> { return new UnsupportedBuiltinExpression("struuid"); }
|	"MD5" "(" Expression() ")" { return new UnsupportedBuiltinExpression("md5"); }
|	"SHA1" "(" Expression() ")" { return new UnsupportedBuiltinExpression("sha1"); }
|	"SHA224" "(" Expression() ")" { return new UnsupportedBuiltinExpression("sha224"); }
|	"SHA256" "(" Expression() ")" { return new UnsupportedBuiltinExpression("sha256"); }
|	"SHA384" "(" Expression() ")" { return new UnsupportedBuiltinExpression("sha384"); }
|	"SHA512" "(" Expression() ")" { return new UnsupportedBuiltinExpression("sha512"); }
|	"COALESCE" ExpressionList() { return new UnsupportedBuiltinExpression("coalesce"); }
|	"IF" "(" e1 = Expression() "," e2 = Expression() "," e3 = Expression() ")" {
         return new If(e1, e2, e3);
    }
|	"STRLANG" "(" Expression() "," Expression() ")" { return new UnsupportedBuiltinExpression("strlang"); }
|	"STRDT" "(" Expression() "," Expression() ")" { return new UnsupportedBuiltinExpression("strdt"); }
|	"sameTerm" "(" Expression() "," Expression() ")" { return new UnsupportedBuiltinExpression("sameterm"); }
|	"isIRI" "(" Expression() ")" { return new UnsupportedBuiltinExpression("isiri"); }
|	"isURI" "(" Expression() ")" { return new UnsupportedBuiltinExpression("isuri"); }
|	"isBLANK" "(" Expression() ")" { return new UnsupportedBuiltinExpression("isblank"); }
|	"isLITERAL" "(" Expression() ")" { return new UnsupportedBuiltinExpression("isliteral"); }
|	"isNUMERIC" "(" Expression() ")" { return new UnsupportedBuiltinExpression("isnumeric"); }
|	"TRIPLE" "(" Expression() "," Expression() "," Expression() ")" { return new UnsupportedBuiltinExpression("triple"); }
|	"SUBJECT" "(" Expression() ")" { return new UnsupportedBuiltinExpression("subject"); }
|	"PREDICATE" "(" Expression() ")" { return new UnsupportedBuiltinExpression("predicate"); }
|	"OBJECT" "(" Expression() ")" { return new UnsupportedBuiltinExpression("object"); }
|	"isTRIPLE" "(" Expression() ")" { return new UnsupportedBuiltinExpression("istriple"); }
|	RegexExpression() { return new UnsupportedBuiltinExpression("regex"); }
|	ExistsFunc() { return new UnsupportedBuiltinExpression("exists"); }
|	NotExistsFunc() { return new UnsupportedBuiltinExpression("notexists"); }
}

// TODO
void RegexExpression():
{}
{
  "REGEX" "(" Expression() "," Expression() ( "," Expression()) ? ")"
}

// TODO
void SubstringExpression():
{}
{
  "SUBSTR" "(" Expression() "," Expression() ( "," Expression()) ? ")"
}

// TODO
void StrReplaceExpression():
{}
{
  "REPLACE" "(" Expression() "," Expression() "," Expression() ( "," Expression()) ? ")"
}

void ExistsFunc():
{}
{
  "EXISTS" GroupGraphPattern()
}

void NotExistsFunc():
{}
{
  "NOT" "EXISTS" GroupGraphPattern()
}

// TODO
void Aggregate():
{}
{
  "COUNT" "(" ("DISTINCT")? ( "*" | Expression() ) ")" |
  "SUM" "(" ("DISTINCT")? Expression() ")" |
  "MIN" "(" ("DISTINCT")? Expression() ")" |
  "MAX" "(" ("DISTINCT")? Expression() ")" |
  "AVG" "(" ("DISTINCT")? Expression() ")" |
  "SAMPLE" "(" ("DISTINCT")? Expression() ")" |
  "GROUP_CONCAT" "(" ("DISTINCT")? Expression() ( ";" "SEPARATOR" "=" String()) ? ")"
}

// TODO
Expression iriOrFunction():
{}
{
  iri() (ArgList())? { return new UnsupportedBuiltinExpression("iriOrFunction"); }
}

LiteralId RDFLiteral():
{
  String s;
  Token t;
  String lang = null;
  IRI i = null;
}
{
  s = String() ( t = <LANGTAG> { lang = t.image; }| ( "^^" i = iri()) ) ? { return DataTypes.getRdfLiteral(s, i, lang); }
}

LiteralId NumericLiteral():
{
  LiteralId l;
}
{
  l = NumericLiteralUnsigned() { return l; }|
  l = NumericLiteralPositive() { return l; }|
  l = NumericLiteralNegative() { return l; }
}

LiteralId NumericLiteralUnsigned():
{
  Token t;
}
{
  t = <INTEGER> { return DataTypes.getIntegerLiteral(t.image); }|
  t = <DECIMAL> { return DataTypes.getDecimalLiteral(t.image); }|
  t = <DOUBLE>  { return DataTypes.getDecimalLiteral(t.image); }
}

LiteralId NumericLiteralPositive():
{
  Token t;
}
{
  t = <INTEGER_POSITIVE> { return DataTypes.getIntegerLiteral(t.image); }|
  t = <DECIMAL_POSITIVE> { return DataTypes.getDecimalLiteral(t.image); }|
  t = <DOUBLE_POSITIVE>  { return DataTypes.getDecimalLiteral(t.image);}
}

LiteralId NumericLiteralNegative():
{
  Token t;
}
{
  t = <INTEGER_NEGATIVE> { return DataTypes.getIntegerLiteral(t.image); }|
  t = <DECIMAL_NEGATIVE> { return DataTypes.getDecimalLiteral(t.image); }|
  t = <DOUBLE_NEGATIVE> { return DataTypes.getDecimalLiteral(t.image);}
}

LiteralId BooleanLiteral():
{}
{
  "true" { return DataTypes.getTRUE(); }|
  "false" { return DataTypes.getFALSE(); }
}

String String():
{
  Token t;
  String s;
}
{
  t = <STRING_LITERAL1> { s = t.image; return s.substring(1, s.length() - 1); }|
  t = <STRING_LITERAL2> { s = t.image; return s.substring(1, s.length() - 1); }|
  t = <STRING_LITERAL_LONG1> { s = t.image; return s.substring(3, s.length() - 3); }|
  t = <STRING_LITERAL_LONG2> { s = t.image; return s.substring(3, s.length() - 3); }
}

IRI iri():
{
 Token t;
 String s;
}
{
  t = <IRIREF> {
    if (t.image.contains(":")) {
      return IRI.create(t.image.substring(1, t.image.length()-1));
    } else {
      return IRI.create(base + t.image.substring(1, t.image.length()-1));
    }


  } |
  s = PrefixedName() { return IRI.create(s); }
}

String PrefixedName():
{
 Token t;
}
{
  t = <PNAME_LN> {
   String[] parts = t.image.split(":", 2);
   return prefixes.get(parts[0] + ":") + parts[1];
  }|
  t = <PNAME_NS> { return prefixes.get(t.image); }
}

BlankId BlankNode():
{ Token t; }
{
  t = <BLANK_NODE_LABEL> { return new BlankId(t.image); }|
  <ANON> { return new BlankId(UUID.randomUUID().toString()); }
}

TermOrVariable.QuotedTriple QuotedTP():
{
 TermOrVariable s;
 TermOrVariable p;
 TermOrVariable o;}
{
  "<<" s = qtSubjectOrObject() p = Verb() o = qtSubjectOrObject() ">>" {
     return new TermOrVariable.QuotedTriple(s, p, o);
  }
}

void QuotedTriple():
{}
{
  "<<" DataValueTerm() ( iri() | "A") DataValueTerm() ">>"
}

TermOrVariable qtSubjectOrObject():
{
  Variable v;
  BlankId n;
  IRI i;
  LiteralId lid;
  LiteralNode l;
  TermOrVariable.QuotedTriple t;
}
{
  v = Var() { return new TermOrVariable.VariableTerm(v); }|
  //FIXME blank nodes should be scoped
  n = BlankNode() { return new TermOrVariable.VariableTerm(new Variable(n.getName(), true)); }|
  i = iri() { return new TermOrVariable.NodeOrIriTerm(new IriId(i)); }|
  lid = RDFLiteral() { return new TermOrVariable.NodeOrIriTerm(lid); }|
  lid = NumericLiteral() { return new TermOrVariable.NodeOrIriTerm(lid); }|
  lid = BooleanLiteral() { return new TermOrVariable.NodeOrIriTerm(lid); }|
  t = QuotedTP() { return t; }
}

// TODO
void DataValueTerm():
{}
{
  iri() |
  RDFLiteral() |
  NumericLiteral() |
  BooleanLiteral() |
  QuotedTriple()
}

TermOrVariable VarOrTermOrQuotedTP():
{
 Variable v;
 TermOrVariable t;
}
{
  v = Var() { return new TermOrVariable.VariableTerm(v); }|
  t = GraphTerm() { return t; }|
  t = QuotedTP() { return t; }
}

void AnnotationPattern():
{}
{
  "{|" PropertyListNotEmpty() "|}"
}

void AnnotationPatternPath():
{}
{
  "{|" PropertyListPathNotEmpty() "|}"
}

Expression ExprQuotedTP():
{
  TermOrVariable v;
  Expression e1;
  Expression e2;
}
{
  "<<" e1 = ExprVarOrTerm() v = Verb() e2 = ExprVarOrTerm() ">>" {
    return new QuotedTripleExpression(e1, new TermOrVariableExpression(v), e2);
  }
}

Expression ExprVarOrTerm():
{
 LiteralId lid;
 IRI i;
 Variable v;
 Expression e;
}
{
  i = iri() { return new LiteralExpression(new IriId(i)); }|
  lid = RDFLiteral() { return new LiteralExpression(lid); }|
  lid = NumericLiteral() { return new LiteralExpression(lid); }|
  lid = BooleanLiteral() { return new LiteralExpression(lid); }|
  v = Var() { return new VariableExpression(v); }|
  e = ExprQuotedTP() { return e; }
}

TOKEN:
{
  <IRIREF: "<" ( ~["\u0000"-"\u0020", "<", ">", "{", "}", "|", "^", "`", "\\"] | <UCHAR>) * ">">
}

TOKEN:
{
  <PNAME_NS: (<PN_PREFIX>)? ":">
}

TOKEN:
{
  <PNAME_LN: <PNAME_NS> <PN_LOCAL>>
}

TOKEN:
{
  <BLANK_NODE_LABEL: "_:" ( <PN_CHARS_U> | ["0"-"9"] ) ( ( <PN_CHARS> | ".") * <PN_CHARS>) ?>
}

TOKEN: {
  <VAR1: "?" <VARNAME>>
}

TOKEN: {
  <VAR2: "$" <VARNAME>>
}

TOKEN:
{
  <LANGTAG:	"@" (["a"-"z", "A"-"Z"]) + ( "-" (["a"-"z","A"-"Z","0"-"9"]) + ) *>
}

TOKEN:
{
  <INTEGER:	(["+", "-"])? (["0"-"9"])+>
}

TOKEN:
{
  <DECIMAL:	(["+", "-"])? ((["0" - "9"])* "." (["0" - "9"])+)>
}

TOKEN:
{
  <DOUBLE: (["+", "-"])? (((["0" - "9"])+ "." (["0" - "9"])* <EXPONENT>) | ( "." (["0" - "9"])+ <EXPONENT>) | ((["0" - "9"])+ <EXPONENT>))>
}

TOKEN:
{
  <INTEGER_POSITIVE: "+" <INTEGER>>
}

TOKEN:
{
  <DECIMAL_POSITIVE: "+" <DECIMAL>>
}

TOKEN:
{
  <DOUBLE_POSITIVE: "+" <DOUBLE>>
}

TOKEN:
{
  <INTEGER_NEGATIVE: "-" <INTEGER>>
}

TOKEN:
{
  <DECIMAL_NEGATIVE: "-" <DECIMAL>>
}

TOKEN:
{
  <DOUBLE_NEGATIVE: "-" <DOUBLE>>
}

TOKEN:
{
  <EXPONENT: ["e", "E"] (["+", "-"])? (["0" - "9"])+>
}

TOKEN:
{
  <STRING_LITERAL1:	"'" ( ~["'", "\\", "\n", "\r"] | <ECHAR>) * "'">
}

TOKEN:
{
  <STRING_LITERAL2: "\"" ( ~["\"", ">", "\\", "\n", "\r"] | <ECHAR>) * "\"" >
}

TOKEN:
{
  <STRING_LITERAL_LONG1:	"'''" (( "'" | "''")? (~["'", "\\"] | <ECHAR> | <UCHAR>))* "'''">
}

TOKEN:
{
  <STRING_LITERAL_LONG2: "\"\"\"" (( "\"" | "\"\"")? (~["\"", "\\"] | <ECHAR> | <UCHAR>)) * "\"\"\"">
}

TOKEN:
{
  <ECHAR: "\\" ["t", "b", "n", "r", "f", "\\", "'"]>
}

TOKEN:
{
  <UCHAR: ("\\u" <HEX> <HEX> <HEX> <HEX>) | ( "\\U" <HEX> <HEX> <HEX> <HEX> <HEX> <HEX> <HEX> <HEX>)>
}


TOKEN:
{
  <NIL: "(" ")">
}

TOKEN:
{
  <ANON: "[" "]">
}

TOKEN:
{
  <PN_CHARS_BASE:
  ["A"-"Z"] |
  ["a"-"z"] |
  ["\u00C0"-"\u00D6"] |
  ["\u00D8"-"\u00F6"] |
  ["\u00F8"-"\u02FF"] |
  ["\u0370"-"\u037D"] |
  ["\u037F"-"\u1FFF"] |
  ["\u200C"-"\u200D"] |
  ["\u2070"-"\u218F"] |
  ["\u2C00"-"\u2FEF"] |
  ["\u3001"-"\uD7FF"] |
  ["\uF900"-"\uFDCF"] |
  ["\uFDF0"-"\uFFFD"]
  // | ["ð€€"-"\uEFFFF"]
  >
}

TOKEN:
{
  <PN_CHARS_U: <PN_CHARS_BASE> | "_">
}

TOKEN:
{
  <VARNAME: ( <PN_CHARS_U> | ["0"-"9"] ) ( <PN_CHARS_U> | ["0"-"9"] | "\u00B7" | [ "\u0300"-"\u036F"] | [ "\u203F"-"\u2040"] ) *>
}

TOKEN:
{
  <PN_CHARS: <PN_CHARS_U> | "-" | ["0" - "9"] | "\u00B7" | ["\u0300"-"\u036F"] | [ "\u203F"-"\u2040"]>
}


TOKEN:
{
  <PN_PREFIX: <PN_CHARS_BASE> ((<PN_CHARS> | ".")* <PN_CHARS>)?>
}

TOKEN:
{
  <PN_LOCAL: (<PN_CHARS_U> | ":" | ["0" - "9"] | <PLX>) ((<PN_CHARS> | "." | ":" | <PLX>)* (<PN_CHARS> | ":" | <PLX>))?>
}
TOKEN:
{
  <PLX: <PERCENT> | <PN_LOCAL_ESC>>
}

TOKEN:
{
  <PERCENT:	"%" <HEX> <HEX>>
}

TOKEN:
{
  <HEX:	["0" - "9"] | ["A" - "F"] | ["a" - "f"]>
}

TOKEN:
{
  <PN_LOCAL_ESC: "\"" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%")>
}
